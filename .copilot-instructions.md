# ConvinceMe Frontend - Copilot Instructions

## Project Overview
ConvinceMe Frontend is a **React + TypeScript** application for a real-time AI debate platform. Users can watch AI vs AI debates, participate in debates, and interact with the system through text and voice. Built with Vite, TailwindCSS, and WebSocket integration.

## Architecture & Core Components

### 🏗️ **Project Structure**
```
convinceme-fe/
├── src/
│   ├── components/              # Reusable UI components
│   │   ├── GameUI.tsx          # Main debate interface
│   │   ├── ArgumentInput.tsx   # User input handling
│   │   ├── AudioPlayer.tsx     # HLS audio playback
│   │   ├── ScoreBar.tsx        # Real-time scoring display
│   │   └── TranscriptList.tsx  # Debate history
│   ├── pages/                  # Route-based page components
│   │   ├── LandingPage.tsx     # Entry point
│   │   ├── LobbyPage.tsx       # Topic/debate selection
│   │   ├── DebatePage.tsx      # Active debate view
│   │   └── TopicSelectionPage.tsx
│   ├── contexts/               # React Context providers
│   │   └── WebSocketContext.tsx # Real-time communication
│   ├── services/               # API and external services
│   │   ├── apiService.ts       # REST API calls
│   │   └── websocketService.ts # WebSocket management
│   ├── contracts/              # Blockchain integration (Starknet)
│   ├── types.ts               # TypeScript type definitions
│   └── constants.ts           # Environment-based constants
├── public/                     # Static assets
└── vite.config.ts             # Build configuration
```

### 🎯 **Core Business Logic**

#### **Debate Flow**
1. **Landing** → **Topic Selection** → **Lobby** → **Active Debate**
2. Real-time WebSocket connection per debate session
3. Audio streaming via HLS with automatic playback
4. Live argument scoring and visual feedback

#### **State Management**
- **React Context**: WebSocket connection state
- **Local State**: Component-specific UI state
- **URL Params**: Debate ID and routing
- **No Redux**: Intentionally lightweight state management

### 🔧 **Key Technologies**
- **Framework**: React 18 + TypeScript + Vite
- **Styling**: TailwindCSS with custom design system
- **Routing**: React Router v7
- **Audio**: HLS.js for streaming audio playback
- **WebSockets**: Native WebSocket API with custom service layer
- **Blockchain**: Starknet integration (@starknet-react/core)
- **Build**: Vite with hot reload

## 🚨 **Critical Patterns & Conventions**

### **Component Architecture**
```tsx
// Always use functional components with TypeScript
interface ComponentProps {
  debateId: string;
  onAction?: (data: SomeType) => void;
}

export default function Component({ debateId, onAction }: ComponentProps) {
  // Hooks first
  const [state, setState] = useState<StateType | null>(null);
  const { connectionStatus } = useWebSocket();
  
  // Event handlers
  const handleUserAction = useCallback((data: SomeType) => {
    onAction?.(data);
  }, [onAction]);
  
  // Effects
  useEffect(() => {
    // Setup/cleanup logic
  }, [dependencies]);
  
  // Early returns for loading/error states
  if (!debateId) return <div>Missing debate ID</div>;
  
  return (
    <div className="responsive-container">
      {/* Component content */}
    </div>
  );
}
```

### **WebSocket Integration**
```tsx
// WebSocket context usage pattern
const { 
  connectionStatus, 
  sendMessage, 
  sendAudio, 
  connectToDebate 
} = useWebSocket();

// Always check connection status before sending
const handleSendArgument = () => {
  if (connectionStatus !== 'Connected') {
    console.warn('Cannot send - not connected');
    return;
  }
  sendMessage(content, topic, username, side);
};
```

### **API Service Pattern**
```typescript
// Consistent error handling for API calls
export const fetchTopics = async (params?: FilterParams): Promise<{
  items: Topic[], 
  pagination: Pagination 
}> => {
  const response = await fetch(buildUrl('/api/topics', params));
  
  if (!response.ok) {
    throw new Error(`Failed to fetch topics: ${response.statusText}`);
  }
  
  return response.json();
};

// Usage in components
useEffect(() => {
  const loadData = async () => {
    try {
      setLoading(true);
      const result = await fetchTopics(filters);
      setData(result);
    } catch (error) {
      console.error('Failed to load:', error);
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };
  
  loadData();
}, [filters]);
```

## 🎨 **Design System & Styling**

### **TailwindCSS Custom Theme**
```typescript
// tailwind.config.js - Custom color palette
colors: {
  surface: {
    dark: '#1a1a2e',
    light: '#16213e'
  },
  primary: '#4f46e5',
  accent: '#06b6d4'
}

// Responsive design patterns
className="
  container mx-auto px-4
  grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3
  gap-4 md:gap-6 lg:gap-8
"
```

### **Component Composition**
```tsx
// Reusable layout components
<div className="h-screen bg-gradient-to-br from-surface-dark to-surface-light">
  <Header />
  <main className="flex-1 container mx-auto px-4 py-8">
    {children}
  </main>
  <Footer />
</div>
```

## 🔐 **State Management Patterns**

### **WebSocket Context**
```tsx
// Centralized WebSocket state
interface WebSocketContextType {
  connectionStatus: string;
  sendMessage: (message: string, topic: string, username: string, side: string) => void;
  sendAudio: (audioBlob: Blob, username: string) => void;
  connectToDebate: (debateId: string) => void;
  isDisabled: boolean;
}

// Provider wraps debate components
<WebSocketProvider debateId={debateId}>
  <GameUI />
</WebSocketProvider>
```

### **Local State Patterns**
```tsx
// Loading states
const [loading, setLoading] = useState(true);
const [error, setError] = useState<string | null>(null);
const [data, setData] = useState<DataType | null>(null);

// Form handling
const [formData, setFormData] = useState({
  username: '',
  argument: '',
  side: 'for' as 'for' | 'against'
});

// UI state
const [isModalOpen, setIsModalOpen] = useState(false);
const [selectedTopic, setSelectedTopic] = useState<Topic | null>(null);
```

## 🎵 **Audio System Integration**

### **HLS Audio Playback**
```tsx
// AudioPlayer component pattern
import Hls from 'hls.js';

const AudioPlayer = ({ audioUrl }: { audioUrl: string }) => {
  const audioRef = useRef<HTMLAudioElement>(null);
  
  useEffect(() => {
    if (!audioUrl || !audioRef.current) return;
    
    if (Hls.isSupported()) {
      const hls = new Hls();
      hls.loadSource(audioUrl);
      hls.attachMedia(audioRef.current);
      
      return () => hls.destroy();
    } else if (audioRef.current.canPlayType('application/vnd.apple.mpegurl')) {
      audioRef.current.src = audioUrl;
    }
  }, [audioUrl]);
  
  return <audio ref={audioRef} autoPlay controls />;
};
```

### **Audio Recording**
```tsx
// Voice input handling
const startRecording = async () => {
  try {
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const mediaRecorder = new MediaRecorder(stream);
    
    mediaRecorder.ondataavailable = (event) => {
      if (event.data.size > 0) {
        sendAudio(event.data, username);
      }
    };
    
    setRecording(mediaRecorder);
    mediaRecorder.start();
  } catch (error) {
    console.error('Failed to start recording:', error);
  }
};
```

## 📡 **API Integration**

### **Environment Configuration**
```typescript
// constants.ts - Environment-based feature flags
export const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:8080';
export const IS_GAME_DISABLED = import.meta.env.VITE_GAME_DISABLED === 'true';
export const WS_URL = import.meta.env.VITE_WS_URL || 'ws://localhost:8080/ws';
```

### **Type-Safe API Calls**
```typescript
// types.ts - Shared type definitions
export interface Topic {
  id: number;
  title: string;
  description: string;
  agent1_name: string;
  agent2_name: string;
  category: string;
}

export interface Debate {
  id: string;
  topic: string;
  status: 'waiting' | 'active' | 'finished';
  agent1_name: string;
  agent2_name: string;
  winner?: string;
}

// apiService.ts - Type-safe service methods
export const fetchDebateById = async (id: string): Promise<{ debate: Debate }> => {
  const response = await fetch(`${API_URL}/api/debates/${id}`);
  if (!response.ok) throw new Error('Failed to fetch debate');
  return response.json();
};
```

## 🔄 **Real-Time Communication**

### **WebSocket Message Types**
```typescript
// Incoming message types
interface AgentResponse {
  type: 'agent_response';
  data: {
    content: string;
    agent: string;
    audio_url?: string;
  };
}

interface ScoreUpdate {
  type: 'score_update';
  data: {
    argument_id: number;
    scores: ArgumentScore;
  };
}

// Outgoing message types
interface UserArgument {
  type: 'user_argument';
  data: {
    content: string;
    side: 'for' | 'against';
    username: string;
  };
}
```

### **WebSocket Service**
```typescript
// websocketService.ts - Connection management
class WebSocketService {
  private ws: WebSocket | null = null;
  private debateId: string | null = null;
  
  connect(callbacks: WebSocketCallbacks, debateId: string) {
    this.debateId = debateId;
    this.ws = new WebSocket(`${WS_URL}?debate_id=${debateId}`);
    
    this.ws.onmessage = (event) => {
      const message = JSON.parse(event.data);
      this.handleMessage(message, callbacks);
    };
  }
  
  sendMessage(type: string, data: any) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      this.ws.send(JSON.stringify({ type, data, debate_id: this.debateId }));
    }
  }
}
```

## 🔧 **Development Workflow**

### **Essential Commands**
```bash
pnpm install           # Install dependencies
pnpm dev              # Start development server
pnpm build            # Production build
pnpm preview          # Preview production build
pnpm lint             # ESLint checking
pnpm format           # Prettier formatting
```

### **Environment Setup**
```bash
# .env.local
VITE_API_URL=http://localhost:8080
VITE_WS_URL=ws://localhost:8080/ws
VITE_GAME_DISABLED=false
```

### **Hot Reload & Development**
- Vite provides instant hot reload for React components
- TypeScript errors shown in browser overlay
- TailwindCSS changes applied immediately
- WebSocket reconnection on code changes

## 🔗 **Blockchain Integration**

### **Starknet Setup**
```tsx
// Starknet wallet connection
import { StarknetProvider } from '@starknet-react/core';
import { sepolia } from '@starknet-react/chains';

<StarknetProvider chains={[sepolia]} autoConnect>
  <App />
</StarknetProvider>
```

### **Wallet Integration**
```tsx
// ConnectButton component
import { useAccount, useConnect, useDisconnect } from '@starknet-react/core';

const ConnectButton = () => {
  const { account } = useAccount();
  const { connect, connectors } = useConnect();
  const { disconnect } = useDisconnect();
  
  if (account) {
    return (
      <button onClick={disconnect}>
        {account.address.slice(0, 6)}...{account.address.slice(-4)}
      </button>
    );
  }
  
  return (
    <button onClick={() => connect({ connector: connectors[0] })}>
      Connect Wallet
    </button>
  );
};
```

## ⚠️ **Common Gotchas**

1. **WebSocket Reconnection**: Handle connection drops gracefully
2. **Audio Autoplay**: Browser policies require user interaction
3. **Memory Leaks**: Always cleanup WebSocket connections and intervals
4. **Mobile Responsiveness**: Test audio recording on mobile devices
5. **CORS Issues**: Backend must allow frontend origin for WebSocket connections
6. **HLS Compatibility**: Safari vs Chrome have different HLS support levels

## 🎯 **Performance Considerations**

### **Component Optimization**
```tsx
// Memoize expensive components
const ExpensiveComponent = memo(({ data }: { data: ComplexData }) => {
  const processedData = useMemo(() => 
    heavyComputation(data), [data]
  );
  
  return <div>{processedData}</div>;
});

// Debounce user input
const [searchTerm, setSearchTerm] = useState('');
const debouncedSearch = useMemo(
  () => debounce((term: string) => performSearch(term), 300),
  []
);

useEffect(() => {
  debouncedSearch(searchTerm);
}, [searchTerm, debouncedSearch]);
```

### **Bundle Optimization**
```typescript
// Lazy load pages
const DebatePage = lazy(() => import('./pages/DebatePage'));
const LobbyPage = lazy(() => import('./pages/LobbyPage'));

// Route-based code splitting
<Routes>
  <Route path="/debate/:id" element={
    <Suspense fallback={<LoadingSpinner />}>
      <DebatePage />
    </Suspense>
  } />
</Routes>
```

## 📱 **Responsive Design**

### **Mobile-First Approach**
```tsx
// Responsive component patterns
<div className="
  flex flex-col md:flex-row
  gap-4 md:gap-8
  p-4 md:p-8
  text-sm md:text-base
">
  <aside className="w-full md:w-1/3 lg:w-1/4">
    {/* Sidebar content */}
  </aside>
  <main className="flex-1">
    {/* Main content */}
  </main>
</div>

// Conditional rendering for mobile
const isMobile = window.innerWidth < 768;
{isMobile ? <MobileNavigation /> : <DesktopNavigation />}
```

## 🔧 **Production Deployment**

### **Build Configuration**
```typescript
// vite.config.ts - Production optimizations
export default defineConfig({
  plugins: [react()],
  build: {
    rollupOptions: {
      output: {
        manualChunks: {
          vendor: ['react', 'react-dom', 'react-router-dom'],
          audio: ['hls.js'],
          blockchain: ['starknet', '@starknet-react/core']
        }
      }
    }
  }
});
```

### **Vercel Deployment**
```json
// vercel.json
{
  "rewrites": [
    { "source": "/((?!api).*)", "destination": "/index.html" }
  ],
  "headers": [
    {
      "source": "/(.*)",
      "headers": [
        { "key": "Cross-Origin-Embedder-Policy", "value": "cross-origin" }
      ]
    }
  ]
}
```

## 📝 **Code Style Guidelines**

- Use TypeScript strict mode - all types must be explicit
- Prefer functional components with hooks over class components
- Use meaningful component and prop names
- Keep components small and focused (< 200 lines)
- Extract custom hooks for reusable logic
- Use ESLint and Prettier consistently
- Comment complex WebSocket message handling
- Handle loading and error states explicitly
- Use semantic HTML elements for accessibility

Remember: This is a **real-time interactive application** - always prioritize user experience, handle network issues gracefully, and ensure responsive design across all devices.
